import{j as m,r as P,q as C,L as A}from"./18e26a01.js";function k(o,e={},t){for(const n in o){const s=o[n],i=t?`${t}:${n}`:n;typeof s=="object"&&s!==null?k(s,e,i):typeof s=="function"&&(e[i]=s)}return e}const T={run:o=>o()},N=()=>T,x=typeof console.createTask<"u"?console.createTask:N;function S(o,e){const t=e.shift(),n=x(t);return o.reduce((s,i)=>s.then(()=>n.run(()=>i(...e))),Promise.resolve())}function W(o,e){const t=e.shift(),n=x(t);return Promise.all(o.map(s=>n.run(()=>s(...e))))}function _(o,e){for(const t of[...o])t(e)}class ${constructor(){this._hooks={},this._before=void 0,this._after=void 0,this._deprecatedMessages=void 0,this._deprecatedHooks={},this.hook=this.hook.bind(this),this.callHook=this.callHook.bind(this),this.callHookWith=this.callHookWith.bind(this)}hook(e,t,n={}){if(!e||typeof t!="function")return()=>{};const s=e;let i;for(;this._deprecatedHooks[e];)i=this._deprecatedHooks[e],e=i.to;if(i&&!n.allowDeprecated){let r=i.message;r||(r=`${s} hook has been deprecated`+(i.to?`, please use ${i.to}`:"")),this._deprecatedMessages||(this._deprecatedMessages=new Set),this._deprecatedMessages.has(r)||(console.warn(r),this._deprecatedMessages.add(r))}if(!t.name)try{Object.defineProperty(t,"name",{get:()=>"_"+e.replace(/\W+/g,"_")+"_hook_cb",configurable:!0})}catch{}return this._hooks[e]=this._hooks[e]||[],this._hooks[e].push(t),()=>{t&&(this.removeHook(e,t),t=void 0)}}hookOnce(e,t){let n,s=(...i)=>(typeof n=="function"&&n(),n=void 0,s=void 0,t(...i));return n=this.hook(e,s),n}removeHook(e,t){if(this._hooks[e]){const n=this._hooks[e].indexOf(t);n!==-1&&this._hooks[e].splice(n,1),this._hooks[e].length===0&&delete this._hooks[e]}}deprecateHook(e,t){this._deprecatedHooks[e]=typeof t=="string"?{to:t}:t;const n=this._hooks[e]||[];delete this._hooks[e];for(const s of n)this.hook(e,s)}deprecateHooks(e){Object.assign(this._deprecatedHooks,e);for(const t in e)this.deprecateHook(t,e[t])}addHooks(e){const t=k(e),n=Object.keys(t).map(s=>this.hook(s,t[s]));return()=>{for(const s of n.splice(0,n.length))s()}}removeHooks(e){const t=k(e);for(const n in t)this.removeHook(n,t[n])}removeAllHooks(){for(const e in this._hooks)delete this._hooks[e]}callHook(e,...t){return t.unshift(e),this.callHookWith(S,e,...t)}callHookParallel(e,...t){return t.unshift(e),this.callHookWith(W,e,...t)}callHookWith(e,t,...n){const s=this._before||this._after?{name:t,args:n,context:{}}:void 0;this._before&&_(this._before,s);const i=e(t in this._hooks?[...this._hooks[t]]:[],n);return i instanceof Promise?i.finally(()=>{this._after&&s&&_(this._after,s)}):(this._after&&s&&_(this._after,s),i)}beforeEach(e){return this._before=this._before||[],this._before.push(e),()=>{if(this._before!==void 0){const t=this._before.indexOf(e);t!==-1&&this._before.splice(t,1)}}}afterEach(e){return this._after=this._after||[],this._after.push(e),()=>{if(this._after!==void 0){const t=this._after.indexOf(e);t!==-1&&this._after.splice(t,1)}}}}function j(){return new $}function E(o={}){let e,t=!1;const n=r=>{if(e&&e!==r)throw new Error("Context conflict")};let s;if(o.asyncContext){const r=o.AsyncLocalStorage||globalThis.AsyncLocalStorage;r?s=new r:console.warn("[unctx] `AsyncLocalStorage` is not provided.")}const i=()=>{if(s&&e===void 0){const r=s.getStore();if(r!==void 0)return r}return e};return{use:()=>{const r=i();if(r===void 0)throw new Error("Context is not available");return r},tryUse:()=>i(),set:(r,c)=>{c||n(r),e=r,t=!0},unset:()=>{e=void 0,t=!1},call:(r,c)=>{n(r),e=r;try{return s?s.run(r,c):c()}finally{t||(e=void 0)}},async callAsync(r,c){e=r;const a=()=>{e=r},f=()=>e===r?a:void 0;g.add(f);try{const u=s?s.run(r,c):c();return t||(e=void 0),await u}finally{g.delete(f)}}}}function O(o={}){const e={};return{get(t,n={}){return e[t]||(e[t]=E({...o,...n})),e[t],e[t]}}}const p=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:typeof window<"u"?window:{},y="__unctx__",I=p[y]||(p[y]=O()),L=(o,e={})=>I.get(o,e),v="__unctx_async_handlers__",g=p[v]||(p[v]=new Set),b=L("nuxt-app",{asyncContext:!1}),M="__nuxt_plugin";function F(o){let e=0;const t={_scope:m(),provide:void 0,globalName:"nuxt",versions:{get nuxt(){return"3.11.2"},get vue(){return t.vueApp.version}},payload:P({data:{},state:{},once:new Set,_errors:{},...window.__NUXT__??{}}),static:{data:{}},runWithContext:s=>t._scope.run(()=>U(t,s)),isHydrating:!0,deferHydration(){if(!t.isHydrating)return()=>{};e++;let s=!1;return()=>{if(!s&&(s=!0,e--,e===0))return t.isHydrating=!1,t.callHook("app:suspense:resolve")}},_asyncDataPromises:{},_asyncData:{},_payloadRevivers:{},...o};t.hooks=j(),t.hook=t.hooks.hook,t.callHook=t.hooks.callHook,t.provide=(s,i)=>{const r="$"+s;d(t,r,i),d(t.vueApp.config.globalProperties,r,i)},d(t.vueApp,"$nuxt",t),d(t.vueApp.config.globalProperties,"$nuxt",t);{window.addEventListener("nuxt.preloadError",i=>{t.callHook("app:chunkError",{error:i.payload})}),window.useNuxtApp=window.useNuxtApp||w;const s=t.hook("app:error",(...i)=>{console.error("[nuxt] error caught during app initialization",...i)});t.hook("app:mounted",s)}const n=t.payload.config;return t.provide("config",n),t}async function D(o,e){if(e.hooks&&o.hooks.addHooks(e.hooks),typeof e=="function"){const{provide:t}=await o.runWithContext(()=>e(o))||{};if(t&&typeof t=="object")for(const n in t)o.provide(n,t[n])}}async function K(o,e){const t=[],n=[],s=[],i=[];let r=0;async function c(a){var u;const f=((u=a.dependsOn)==null?void 0:u.filter(h=>e.some(l=>l._name===h)&&!t.includes(h)))??[];if(f.length>0)n.push([new Set(f),a]);else{const h=D(o,a).then(async()=>{a._name&&(t.push(a._name),await Promise.all(n.map(async([l,H])=>{l.has(a._name)&&(l.delete(a._name),l.size===0&&(r++,await c(H)))})))});a.parallel?s.push(h.catch(l=>i.push(l))):await h}}for(const a of e)await c(a);if(await Promise.all(s),r)for(let a=0;a<r;a++)await Promise.all(s);if(i.length)throw i[0]}function q(o){if(typeof o=="function")return o;const e=o._name||o.name;return delete o.name,Object.assign(o.setup||(()=>{}),o,{[M]:!0,_name:e})}function U(o,e,t){const n=()=>t?e(...t):e();return b.set(o),o.vueApp.runWithContext(n)}function R(){var e;let o;return C()&&(o=(e=A())==null?void 0:e.appContext.app.$nuxt),o=o||b.tryUse(),o||null}function w(){const o=R();if(!o)throw new Error("[nuxt] instance unavailable");return o}function G(o){return w().$config}function d(o,e,t){Object.defineProperty(o,e,{get:()=>t})}export{w as a,F as b,j as c,q as d,K as e,G as u};
